== Bitmap Editing and Texture Workflow

This chapter describes practical methods for creating, editing, and exporting textures for 3D models. It focuses on clear, repeatable workflows and avoids tool-specific bias. Texturing, like modeling, improves with regular practice.

=== UV Mapping Overview

UV mapping (also called unwrapping) defines how a 2D image is applied to a 3D surface. The process involves laying out a model's polygons on a flat 2D plane, forming a UV map. During rendering, the GPU uses this map to wrap the texture image onto the model's geometry.

[NOTE]
UV mapping and 3d object unwrapping are the same process. The term simply refers to creating a 2D layout of a 3D mesh for texture application.


.Author's Note
----
I'm not an Adobe evangelist. My goal is to help you get great results with the tools you prefer—whether they are free/open-source or commercial. If you're new to texturing, starting with a free tool is perfectly fine. If you're already comfortable with a particular bitmap tool, the techniques in this guide focus on workflows that use layers, which most modern tools support.

My concern with Adobe products is the subscription model, you pay monthly just to keep access to the software. If you already subscribe, it makes sense to continue using the tools you know. But I do not recommend purchasing Adobe Photoshop solely for occasional 3D texturing work.
----

=== Bitmap Tools Overview
In this section, we will provide an overview of the various bitmap tools available and why they are important for creating textures for 3D models. We will also discuss the features and capabilities of bitmap tools that make them essential for texture creation and editing.

(((Texture, "Tools Overview")))


==== Bitmap Tools Overview

Bitmap (raster) editors let you paint and manipulate pixels on a grid. They're essential for photo editing, digital painting, and texture authoring. Typical features include layers, blend modes, masks, brushes, filters, color correction, and precise per-pixel control. Popular choices include GIMP, Krita, Paint.NET, Affinity Photo/Designer, and Photoshop. Raster images are resolution-dependent—scaling them up can reduce quality—so work at an appropriate resolution from the start.

==== Why bitmap tools matter for 3D

Proper bitmap tools or pixel based editors are crucial for creating and refining textures for 3D models because they allow artists to craft the detailed surface details that make a model appear realistic and visually appealing.  A pixel editor enables artists to create intricate textures, such as fabric patterns, skin details, metallic finishes, or weathering effects. These details are mapped onto the surface of 3D models, bringing them to life by simulating real-world materials. Bitmap tools bridge the gap between 2D artistry and 3D modeling, enabling the creation of rich, lifelike textures that elevate the visual quality of 3D assets.  Finding the right tool for the job is essential for creating high-quality, realistic 3D assets but in the end, its up to what fits your workflow and preferences.


=== Layered Format Files

(((File Formats with Layer Support)))

For serious texture work you should be using layers (with opacity and blend modes). Save a master file that preserves layers; export flattened copies for your game/sim.

To recommend a few tools and formats, the following list should be a guide on what you can use (These all support layers):

|===
| Tool                  | File Type |   Comment 

| Affinity Studio       | .af       |   Proprietary, Native
| Affinity Studio       | .psd      |   An Import/Export Option
| Affinity Studio       | .tiff     |   An Import/Export Option
| Gimp                  | .xcf      |   Native
| Gimp                  | .psd      |   An Import/Export Option
| Gimp                  | .ora      |   An Import/Export Option (plugin)
| Krita                 | .krt      |   Native
| Krita                 | .ora      |   An Import/Export option
| Krita                 | .psd      |   An Import/Export Option
| Krita                 | .tiff     |   An Import/Export Option
| Paint.Net             | .pdn      |   Native
| Paint.Net             | .psd      |   An Import/Export Option
| Paint.Net             | .ora      |   An Import/Export Option (plugin)
| Paint.Net             | .dds      |   An Import/Export Option, Alpha Only
| PaintShopPro          | .psp      |   Proprietary, Native
| PaintShopPro          | .psd      |   An Import/Export Option
|===

[NOTE]
You will not find Adobe Photoshop listed here. Photoshop continues to rely on its native PSD file format, and if you already own (or subscribe to) it, it is certainly capable of producing layered textures. I no longer use Photoshop and cannot speak confidently about its current import/export capabilities, but it is reasonable to assume that PNG and DDS are supported.

* All of the above programs support the `PNG` image export format, used for final textures.
* Some of the above support `DDS` image format, eg. Paint.Net and GIMP through the use of external plug-ins
* The `PSD` format was originally a proprietary format used by PhotoShop and some software has trouble opening all `PSD` format variations seen in the wild
* `TIFF` is also a layered format, though not as common and in some cases prone to some tools not fully understanding file contents. Testing is needed.
* Open Raster, `ORA`, is a newer file format that is supposed to replace `PSD` as a standard solution for exchanging layered images between graphics editors. It's still not widely used.

[TIP]
One additional tool to mention is InkScape, which like Affinity Studio, is a Vector Graphics program that contains a "make a bitmap copy" option.  Vector graphics are scalable without creating "jaggies" like you see with bitmaps. Like Affinity Studio, Inkscape is free.

[TIP]
DDS uses lossy compression. Treat DDS like a final delivery format (similar to PDF for documents), not a master format for repeated edits. Always keep a lossless layered master.

[WARNING]
Very simple editors (e.g., legacy MS Paint) are poor choices for layered texture work.

[NOTE]
----
While the list above does not attempt to catalogue every bitmap editor capable of using layers, it highlights the most common options in regular use.
----



In summary, choose a tool that has a native layered file format that can also support PNG and possibly DDS.  For maximum compatibility, choose a free tool, like GIMP or Paint.net, otherwise, save your master documents in `PSD` or `ORA` format

You can do some rudimentary texture painting inside blender.   Many improvements have been made in recent years, but it's still a bit clunky.  You can use the paint tools to create some basic textures, but it's not as good as using a dedicated tool.  You can also use the texture editor in blender to create more complex textures, but it's still not as good as using a dedicated tool.  

The best approach is to use a dedicated tool for texture creation and editing.  There is also a free add-on called UCUPAINT (from Blender Extensions) that can be used to create textures in Blender.  It's not as good as a dedicated tool, but it's a decent starting point if you want to try it.  It has a number of options though that are probably overkill for {OR} texture creation.

While some tutorials mention `Substance Painter`, it also falls into the category of overkill for {OR} texture creation.  It's a great tool for creating complex materials, but it's not necessary for {OR} texture creation.  If you already have it and want to use it, it's a good idea to use it for creating the base textures and then export them as PNG or DDS for use in {OR}.  There is pretty much no reason to get it if you are only going to use it for {OR} texture creation.

=== Using DDS Textures

(((Texture, "DDS FILES")))

DDS (DirectDraw Surface) stores GPU-friendly compressed textures (with optional mipmaps). Benefits include smaller memory footprint and fast GPU upload. Ideal for large scenes or hardware with limited VRAM. Export from modern editors (Paint.NET, GIMP+plugin) rather than legacy tools.

(((Texture, "DDS FILES")))
Using `.DDS` textures for your materials has the advantage of reducing the memory usage of textures by slightly decreasing their quality (Though honestly, not as bad as the ACE file format). This is helpful if you have a limited amount of graphics card and system memory and want to include as many textures as possible. Additionally, this method is particularly suitable for organic/nature textures where precision is not critical.

[CAUTION]
Always maintain a layered, lossless master. Do not round-trip edit DDS; repeated saves degrade quality.

For working with DDS, the easiest approach is to utilize Paint.net or GIMP as both can export DDS textures directly. Exporting large 32-bit ACE textures using the original MSTS tools is often not feasible and some people won't even have access to MSTS tools if they only use {OR}.  The most significant advantage of using GIMP or Paint.net is that exporting is much more straightforward and faster compared to outdated programs like TgaTool2.

DDS is a useful format but many of the export options are not suitable for best performance.  

The short explanation is:

Always use DXT1 compression with full MIPs, except...  you can use DXT5 compression when you need alpha translucency ( ie; alpha values other than on/off )

One of the most significant performance issues with current GPUs is related to the texture size. All textures used on loaded tiles in a scene must fit into the GPU at once. Although modern GPUs have 2G, 4G or more, adding up the texture file sizes for all buildings, terrain, and rolling stock will quickly reveal that the GPU's capacity can be reached. This is especially true when using 2K and 4K textures. When the GPU reaches its limit, performance suffers because additional textures must be swapped out to the CPU every frame.

So maximum compression is the key to good performance. Just compare the size of uncompressed textures and you will see how bloated they are.

(((Texture, "DXT COMPRESSION")))

|===
|    TYPE           | USAGE                            | Comment
|    DXT1 no alpha  | Textures without transparency    | Normal maps without shine, All glow maps
|    DXT3           | Menu icons / UI elements         | No mipmaps but has transparency
|    DXT5           | Textures with transparency       | Mip Maps and Normal maps with shine (if we ever get that ability)
|===

An alpha channel increases the file size so it should be left out unless it is needed. On color maps, the alpha channel is used for transparency, on normal maps for glossiness. If the texture has no transparency or the normal map has no glossiness saving them as DXT1 (no alpha) instead of DXT5 instantly saves on the file size for no loss. 

.Authors Note
----
You know how sometimes people report that their icons or textures become a rainbow pixel mess? That is related to Gimp saving the "no mipmap" textures incorrectly, it writes in the header that the image has 1 mipmap, but it has none and the game gets confused. I never used Gimp and I can't find where I read about this right now, but if I'll do, I'll update this comment.
----

[TIP]
Ensure you are keeping uncompressed versions of the source files that you can load for editing so you don't accumulate compression artifacts.

With *GIMP*, you would use `export as` and then chose `select file type` and set the options for DDS such as Compression, mipmap, etc. Latest versions if GIMP seem to come with DDS support so no post-install plugin is needed.

With *Paint.net* versions newer than 4.2.2, DDS support comes bundled with the program. You would use the `save as` option and `save as type:  DDS`. In the Save Settings window, you would select *DXT1* and under *Error Metric*, and check *Generate Mip Maps* and *Use Best Quality*.


== Using ACE Textures

(((Texture, "ACE")))


{msts} uses a proprietary Kuju image file format known as ACE (extension `.ACE`).  ACE files are used for textures applied to shapes and the bitmaps used for the cab panels and controls aka. bitmap ACE's.

[NOTE]
A conversion utility called `MAKEACE.exe` was supplied with {MSTS}. Newer tools have been created that eliminate some of the limitations that come with the original and updated `MAKEACE` program.

[TIP]
{OR} has the ability to automatically use DDS files if they are present, even if the model's `S` file defines an ACE file.  This is a great way to use DDS files without having to convert them to ACE files.  The downside is that the DDS files are really not editable as they will lose detail on every export.  In other words, the DDS files use a lossy compression method, which means you will lose detail and color information compared to the original texture.

=== ACE File Types:
There are three types of ACE files:

Solid::  these are created by converting 24-bit BMP or TGA files and the resulting ACE file contains only solid pixels.  You might use such ACE files for the general texture detail on buildings and trains you are creating.

Trans:: these are created by converting 32-bit TGA files and specifying the transparency mask option.  The resulting ACE file will contain both solid pixels and transparent pixels.  You can still use solid areas of this ACE type for the general texture detail on your object but in addition you can use areas containing transparent pixels for details such as railings, ladders and other areas that require the appearance of a "hole" in your object.  This is also a good choice for simple cab backgrounds and controls.

Alpha:: these are creating by converting 32-bit TGA files and not specifying the transparency mask option.  The resulting ACE files will contain solid and both partially and completely transparent pixels.  This texture type can be used in a similar way to the Trans type, except it also allows you to create effects such as tinted windows.

=== ACE File Compression
There are two types of compression that can be applied to ACE files:

No compression:: the image is stored uncompressed.

ZLib compression:: this is a lossless compression technique similar to that used by programs such as PKZIP and WinZip.

DXT compression:: this is a lossy technique that can only be used for Solid and Trans type texture ACE files.  It may create unwanted artifacts.

[WARNING]
DXT compression cannot be used for bitmap ACE files.

[NOTE]
For Alpha type ACE files you cannot use DXT, so the recommended option is ZLib.

[TIP]
I'm relatively sure that even the updated MAKEACE only supports textures up to 1024 x 1024 in size.

=== Digital Graphics Basics

(((Graphics Basics)))

The following is a brief introduction to some of the basic concepts of digital graphics.

==== Bit Depth and Color Depth

Color depth describes the maximum number of colors an image can contain. This is dependent on the bit depth of its pixels. The higher the bit depth value, the more color information each pixel can display and the greater the number of colors the image can contain.

==== Bit Depth

Bit depth is a value that describes the number of colors that an individual pixel can display. A bit can either be on or off. Therefore, a 1-bit pixel can display two colors: black and white. An 8-bit pixel displays 256 colors. Each bit can be on or off (2 states). When combined in eight different ways (2x2x2x2x2x2x2x2 or 28) it can display up to 256 colors.

Pixels are usually one of five standard bit-depths. Rarely is anything above 8 bits necessary.

|===
|Bit Depth	    |No. Colors	    |Calculation
|1	            |2	            |2^1
|8	            |256	        |2^8
|16	            |65,536	        |2^16
|24	            |16,777,216	    |2^24
|32	            |16,777,216 plus 8-bit alpha channel    |24 + 8 bits
|===

==== Color Depth

Sometimes the terms bit depth and color depth are used interchangeably. We're going to use the term color depth to describe the overall ability of an image to display colors. The distinction lies in the fact that some color modes use more than one color 'channel'. For example, The RGB color mode contains 8 bits in each of its three color channels (red, green, blue) giving an RGB image a color depth of 24 bits (8 bits per channel x 3 channels). Below are examples of an image displayed in various color modes to demonstrate how image quality and file size are affected.

==== Color Modes and Bit Depth

|===
| 1-bit bitmap image	| Color Mode: Bitmap, Color Depth: 1-bit (1 channel x 21), Colors: 2, File Size: 4 kb (as GIF)
| 4-bit indexed color image	| Color Mode: Indexed Color, Color Depth: 4-bit (1 channel x 24), Colors: 16, File Size: 8 kb (as GIF)
| 8-bit gray-scale image	| Color Mode: gray-scale, Color Depth: 8-bit (1 channel x 28), Colors: 256, File Size: 24 kb (as GIF)
|8-bit indexed color image	|Color Mode: Indexed Color, Color Depth: 8-bit (1 channel x 28), Colors: 256, File Size: 16 kb (as GIF)
|24-bit RGB image	|Color Mode: RGB, Color Depth: 24-bit (3 channels x 8 bits per channel), Colors: 16,777,216, File Size: 12 kb (as JPEG)
|===

The increase in file sizes theoretically should be proportional to the number of bits used in an image; however, the difference in GIF and JPEG compression resulted in a smaller-than-expected 24-bit image file size.

Photoshop supports 16 bits per channel. This provides for slightly better color rendering (if your monitor supports it) but increases the file size dramatically. A 16-bit pixel will display 65,536 shades of color. For Web graphics, this would be overkill.

==== Bit Depth and Color Depth Summary

* Bit depth is a value that describes the number of colors that an individual pixel can display.
* The higher the bit depth, the more color information it can display.
* Color depth describes the maximum number of colors an image can display.
* An image's color depth is dependent on the bit depth of the image's pixels and the number of channels it contains.
* The file size of an image is proportional to its color depth.


=== JPG Format, lossy compression and UpScaling

(((Texture, "JPG Format"))) 

JPG is a lossy compression format. It is a compression format that is designed to reduce the file size of an image while maintaining the quality of the image.  It should be avoided for images that contain text or graphics with fine detail and is really not suitable as a general-purpose "saved" image format for the textures used in the simulator.

(((Texture,"Upscaling")))

A new thing to try though is Artificial Intelligence (AI) tools that offer image upscaling.  Many have tried this and have shown that can offer some improvement to the master textures that needed to be a bit larger and sharper.  One example is https://www.topazlabs.com/gigapixel from Topaz Labs.  It is not a free tool but it does offer a free trial.  It is a bit expensive but it does offer some improvement to the textures.  

Another option is to try https://github.com/upscayl .  Upscayl is a free and open source desktop application that lets you upscale your low resolution images using advanced AI Models. It is a bit slow but it does offer some improvement to the textures. 


=== PNG Format

(((Texture, "PNG Format")))

Portable Network Graphic is a new bitmap file type developed in part with the Internet in mind. Its development was instigated by the GIF licensing issue and was intended as a replacement for GIF.

There are two PNG sub-types, *PNG-8*, and *PNG-24*. Both use the same compression method. PNG-8 supports a single alpha channel and PNG-24 supports variable transparency (covered later). PNG-8 is limited to 8-bit color depth (256 colors), and PNG-24 can have millions of colors (24-bit color depth). Both are lossless compression formats

=== PNG Format Summary

* The Portable Network Graphic format was designed to replace GIF.
* PNG-8 supports 256 colors and a single alpha channel.
* PNG-24 supports 16.8 million colors and variable transparency.

=== Vector Graphics

(((Vector Graphics)))

Vector graphics are created by a computer program using mathematical formulas. The program draws lines and curves using mathematical formulas. The program then stores the formulas in a file. The file contains the information needed to recreate the image. Programs that create vector graphics are called vector graphics editors. Examples are Adobe Illustrator, Affinity Studio and Corel Draw and Inkscape.

Vector graphics are referred to as resolution-independent because they do not plot images on a pixel-by-pixel basis and so are not tied into a monitor's resolution. Vector images describe images in terms of shapes, lines, curves, points, colors, length, etc. These images rely only on the resolution of an output device (like a printer for example) to determine their final resolution.  Examples of images suitable for vector graphics are logos and type.  

[WARNING]
Vector graphics are not suitable as a replacement for bitmap images, but they are suitable for logos and typed lettering inside bitmap images that then get rasterized.

[NOTE]
Fonts used by windows programs are vector graphics.  This is why RailSimStuff creates their own fonts with railroad symbols and logo's for others to use.

==== Vector Graphics Summary

* There are two main types of digital graphic files: bitmap and vector.
* Vector files are resolution-independent.
* Vector graphics use mathematical formulae to create the image, not pixels on a grid like bit-mapped images.
* Simple vector images can be quite small compared to bitmap; complex images like photographs are difficult and inefficient with vectors.
* Bitmap is still more common than vector.
* Vector images can scale without loss of detail or a change in file size.
* Vector graphic images must be rasterized into a bitmap format for use as a 3D model texture image.



=== Preparing a texture
(((Texture, "Preparing a texture")))

.When creating textures. remember
[quote, Erick Cantu]
Texture mapping needs to be intuitive and functional.

Probably the best way to start a texture file is to create a background layer that contains the primary colors of your final model.  If your base model is primarily "Tuscan Red", then fill your background with "Tuscan Red".  Variants for Pennsylvania, for example, would be RED rgb(121,68,59), BROWN rgb(111,78,55), TAN rgb(166,123,91).  Many tools allow you to enter a RGB color value into your editor.

You don't need to complete your texture before you apply it to your 3D Model.  Even starting with the single base color would be OK.

For texture size, consider working with 2048x2048 textures.  Try to avoid creating multiple smaller texture files versus one large file.  You can always shrink your texture to 1024x1024 when all your work is done as the coordinate mapping will remain relative as long as the proportions remain the same.  You could not, however, adjust 2048x2048 to 2048x1024 though, keep that in mind. 

If your model is wide but not tall, as many vehicle models are, then you might consider starting with a 2048x1024 texture size, provided that you are only creating content for Open Rails.  Open Rails will not have issues with textures that are not square, unlike {msts}.  

Once you have created your base texture for your model, you should a) Save it in the native format of your editor or in one of the Layered formats like `PSD` or `ORA`. b) Save a copy in `PNG` format for use with Blender.  Copy the `PNG` file to your project folder for your current model so it is easily available during a Blender working session.

Keep in mind that some people who might consider repainting your model will want to make use of their own photographs of actual vehicles or buildings.  This means that it would be "unkind" to these "re-skinners" if you were to split up the sides of your model into multiple sections as they would have difficulty getting the sections to rejoin cleanly from their photographs.  Try to keep the side and top views as continuous shapes in your model and your textures.  However, if the model is unlikely to be re-skinned by 3rd parties, then you can conceivably create a separate texture for each section of the model.  This will allow you to rejoin the sections as needed.


[TIP]
For scenery like brick buildings, use a seamless base layer (e.g., brick) below windows/doors layers.


=== Which Comes First?

The model or the texture?  It depends on your references and goals.  

* Texture first: works when starting from photos and rough dimensions.

* Model first: is best with drawings/specs; unwrap, UV → Export UV layout, paint against the guide, then replace the blank texture in Blender.


=== UV Mapping Basics

(((Texturing, "UV Mapping Basics")))

image::images/tex-uvmap.jpg[]


=== Setting up Blender for Texture Mapping and Baking 

(((Texturing, "Setting up Blender for Texture Mapping and Baking")))

_This section contributed by Scott Brunner._

This is intended as a primer, not a tutorial, so we'll be addressing the concepts involved that need to be considered for Mapping and Baking operations in Blender.

.Author Tips
----
Blender is an application that can utilize 3rd-party addons and there are thousands of them.  I'll only be discussing a few that I find essential for {OR} related work. These are free. I've tried many others as well and another modeler might prefer a different set of addons. Experimentation is key here. 
----

image::images/AO_Init.png[]

In this setup, Blender 4.3 is being used and since Blender 4.2 many of the external addons are now available in the *Get Extensions* option under *Preferences*. *Texel Density Checker* is available via *Get Extensions* in Blender 4.3. *UV Layout* is an official Blender addon available via *Add-ons* option. The last one,  *TexTools*,  is available from GitHub and needs to be installed from the downloaded zip file.

Texel Density Checker:: shows up the *N Side Menu* when in the *UV Mapping* window. It allows you to get or set the bitmap density of a UV island.  For the best-looking models, you want a relatively consistent texel density, and this add-on makes it extremely easy to set on each island as you map it.

UV Layout:: adds mapping functions to the *Top Menu* in the *UV Mapping* window. Some of the most important features are the ability to export your *UV Map* to a texture file so you can load it into your paint program, and the *Pack Islands* function help to pack your islands in the most efficient manner possible.

TexTools:: shows up the *N Side Menu* when in the *UV Mapping* window. This adds a host of operations for manipulating your *UV Map* and single click *Baking*. If you've tried the default Blender *Baking* operation - this add-on makes your life much easier.

Textools Download: https://github.com/franMarz/TexTools-Blender

Textools Addon Video: https://www.youtube.com/watch?v=rEcJQ6Jdue4


Lets do a quick review of terms again...

(((Texturing, "Common Terms")))

Texel Density:: - refers to the number of texture pixels (texels) per unit of 3D surface area. It's an important concept for ensuring that textures appear consistent and detailed across different parts of a model. Maintaining a consistent texel density is crucial for achieving a uniform look, especially when combining multiple objects in a scene.​  For isolated objects, a higher texel density can be used to create a more detailed look. Example: Air line hoses might benefit from a higher texel resolution than a typical car body.

Seams:: - are the edges where a 3D model is "cut" or "split" during the unwrapping process. These cuts allow the 3D surface to be laid out flat in 2D space with minimal distortion. *Seams* only work under the following *Unwrap* operations: *Angle Based*, *Conformal*, and *Minimal Stretch*. _Regarding *Minimal Stretch*, this might have been added in Blender 4.3._

UV Mapping or Unwrapping:: - is the process of projecting a 2D image texture onto a 3D model's surface. It involves unwrapping the 3D model into a flat 2D plane, much like peeling an orange and laying its skin flat. This allows textures, such as images or patterns, to be precisely applied to the model, ensuring that each part of the texture aligns correctly with the corresponding part of the model's surface.

UV Vertex or UV:: - is a point in the 2D space of a UV map that corresponds to a vertex on a 3D model. These UV vertices are used to define the position of the texture coordinates, determining how a 2D texture is applied to the surface of the 3D model. Essentially, they serve as the anchors for mapping the texture accurately onto the model's surface, ensuring that the details of the texture align correctly with the geometry of the model.

UV Island:: - is a contiguous group of UV vertices and edges that form a separate, unbroken piece of the UV map. It represents a section of the 3D model's surface that has been unwrapped and flattened for texturing purposes. Each *UV Island* typically corresponds to a distinct part of the 3D model, making it easier to apply detailed textures accurately.

Pack Islands:: - in *UV mapping* is the process of organizing and arranging *UV Islands* efficiently within the UV space to maximize the use of texture space. You can do this with entire texture sheets or any subset therein. You can define a Margin to set how much space is kept between Islands.

Tiling Texture:: - is a small, seamless image or pattern that is repeated, or "tiled," across a surface to create a continuous, uniform appearance. This technique is particularly useful for covering large areas without visible seams or repetitions, like walls, floors, or any large surfaces in 3D environments. By seamlessly repeating the texture, it allows for efficient use of memory and resources, as a single small texture can cover extensive areas without noticeable patterns or disruptions.

Swatches:: - I don't think this is an official name - just what I call it. It's using small little swatches of material - that won't have any detail or baking applied - used on small parts, edges, or parts that aren't seen often.

Baking:: - refers to the process of capturing detailed lighting, shading, and other surface information, such as ambient occlusion and reflections, and storing it in a texture map. These affects are created with Ray Tracing and add a great deal of "pop" to any model.

Ray Tracing:: - is a rendering technique used in computer graphics to simulate the way light interacts with objects in a scene to produce highly realistic images.

Material:: - defines how a 3D object's surface interacts with light and gives it its color, texture, and reflective properties. If you change the specular shine on two different objects mapped to a single texture - that will require two *Materials*.

Draw Calls:: - for our purposes - it's every time we need to load a texture sheet to the video card - which is a resource intensive process - *Draw Calls* significantly impact performance - so you want to minimize them. Each *Material* you use - will - at a minimum - be a single *Draw Call*.

Ambient Occlusion or AO:: - is a shading and rendering technique used to calculate how exposed each point in a scene is to ambient lighting. It simulates the soft shadows and subtle shading that occur in corners, creases, and near intersections of objects, where light is less likely to reach. This effect adds a sense of depth and realism to the scene by enhancing the perception of surface details and contact points between objects.

[TIP]
Unique texture real estate - if you want to apply details or baked textures - you need to ensure no UV Island overlaps another. Baking also has an option to adjust the margin size.

.Scott's Example

I'll be using the RS3 as a reference model. I typically start out with two fairly large texture sheets - one for parts that have a Specular Shine and another for Flat or no shine parts. Typically - the upper painted metal body gets shine - the lower body does not. Some parts don't look good with shine - like handrails - so experiment and see what works best for you. I'll be focusing on the main body of the model for our discussion - as the trucks/bogies are a child - forcing a *Draw Call* - so it makes sense to have a separate texture just for them.

On the following texture images - a couple things to note:

The first two images are of the same flat texture - one with *Ambient Occlusion* and one without. It clearly shows how much you gain by taking the time to *Bake* *AO* into your textures. It's practically required.
On the first two images - you can see the *Swatches* I use on various parts of the model - the hinges are probably the most identifiable. Multiple parts overlay each other in these little squares so the {ao} makes a mess of this - if it's included in the *Bake*. In your paint program this is easily addressed by simply placing the *Swatch* layer above your {ao} layer.

image::images/Prime-Flat-No-AO.jpg[]
image::images/Prime-Flat.jpg[]
image::images/Prime.jpg[]


==== Using SEAMS to Unwrap the Model

(((UV Mapping, "Seams")))


To create a seam - you must be in edit mode - select the desired edges - then menu:Edge[Mark Seam].

Applicable Commands:

kbd:[L] - Select all parts by Texture or Seam.

Seams Supported Unwraps:

* *Angle Based*
* *Conformal*
* *Minimal Stretch*

===== Purpose of Seams

Unwrapping the Model:: Seams allow you to "cut" your 3D model so it can be laid out flat in 2D space, similar to how you might cut and unfold a cardboard box. This process is known as unwrapping.
Reducing Distortion:: By strategically placing seams, you can reduce the amount of distortion that occurs when the 3D model is flattened. This helps to ensure that textures are applied accurately and without stretching.
Isolating UV Islands:: Seams help define UV islands, which are separate, contiguous areas of the UV map. These islands can be textured more precisely, making it easier to apply detailed textures to specific parts of the model.
Texture Alignment:: Well-placed seams help align textures correctly, minimizing visible mismatches and ensuring a seamless appearance on the final model.


===== How to Place Seams

Strategic Placement:: Place seams in less visible areas of the model, such as along edges or in natural creases, to minimize their appearance in the final texture.
Testing Unwraps:: Experiment with different seam placements and unwraps to find the best configuration that minimizes distortion and maximizes texture quality.
Consistency:: Ensure that the seams create manageable UV islands that make texturing easier and more efficient.

<<<

Marked Seams in Red

image::images/Seams1.jpg[]

Select Desired Faces by Seam - Pressing kbd:[L] - Faces Must Be Fully Enclosed by Seams for Selection to Work

image::images/Seams2.jpg[]

Conformal Unwrap

image::images/Seams3.jpg[]

Results in (3) Perfectly Unwrapped Islands

image::images/Seams4.jpg[]


<<< 
    
Same Conformal Unwrap Without the Use of Seams - Completely Unusable

image::images/Seams5.jpg[]


Once you have your *UV Islands* - you can set their *Texel Density* using *Texel Density Checker* - make sure you set your texture size appropriately on the top of the *Texel Density Checker* tool panel. Then just move them to where you want them placed on your texture.

You can save your *UV Map* to a texture file in the *UV Mapping* window by selecting *UV* *Export UV Map*. I would suggest setting the *Fill Opacity* to 1 for best results. It basically gives you a page out of a coloring book to apply your textures to.

One other important tip in the *UV Mapping* window - on the top left toolbar - there's a tiny little icon that has two arrows - one up the other down - at a 45 degree angle. This synchronizes the *UV Map* to your mesh. Where this comes in handy - you can select a *UV Island* and you may not know what it's mapped to - then move your mouse over to the *3D Viewport* and press kbd:[.] - it focuses and zooms in on the object that is mapped to your *UV Island*. Extremely helpful.

_So easy a caveman could do it._

image::images/UVmap.jpg[]


==== Packing Islands

(((UV Mapping, "Packing Islands")))

Pack Islands:: - in *UV mapping* is the process of organizing and arranging *UV Islands* efficiently within the UV space to maximize the use of texture space. You can do this with entire texture sheets or any subset therein. You can define a Margin to set how much space is kept between Islands.

In practical use - you're probably going to be unwrapping far more faces than I did in my example above. You probably want to group them by texture used and perhaps proximity to each other. Instead of manually trying to juggle your *UV Islands* - Blender has included a great tool called *Pack Islands*.


*Realistic Unwrapping*

image::images/Pack1.jpg[]

*Set Your Texel Density as Required*

image::images/Pack2.jpg[]

*Pack Islands - menu:UV[Pack Islands] - Uncheck Scale - Set Your Margin*

image::images/Pack3.jpg[]

*Result - An Efficiently Packed Group of UV Islands*

image::images/Pack4.jpg[]

The packed group of UV Islands - is ready to be moved where desired on your texture sheet.

==== Windows 

(((textures, "Windows)))


* Separated the glass faces into its own object.
* Apply a greyish blue texture partially translucent - `RGBA = 25, 28, 32, 220`
* In the MSTS Materials panel, set the Transparency to `Alpha Sorted, Lighting = Normal`.

[NOTE]
Other Blender users have had success with using `alpha blended transparency`

[TIP]
Don't use DXT compression when you make your .ace file.


==== Texture Nodes

(((Texture, "Texture Nodes")))

Texture nodes are a powerful tool in Blender that allow you to create complex and dynamic textures. They allow you to create procedural textures, blend multiple textures together, and apply filters and transformations to your textures.  The problem is, that while these are powerful tools, the methods for creating them can be a bit daunting and not as useful as they might seem in our texture creation scenario.  You would likely be better off with using the texture baking process to create your textures.

Lastly, the NODE system in Blender is a new-ish feature and is somewhat hard to explain.  No additional mention of it will be made.

==== Decals

(((Texture, "Decals")))

A newer _concept_, and one championed by the NAVS technique, is to use a separate bitmap or multiple bitmaps to generate various car numbers without having the numbers be part of the main bitmap.  This gives added flexibility to car rosters as custom car numbers are easily generated without resorting to difficult post-release editing of `.ACE` or `.DDS` files as many have done in the past. Changing numbers that are part of a final bitmap are particularly difficult.

A DECAL using this method is a small section of the main model that has a smaller `3d plane` object floated just above the surface of the model. This plane is assigned a set of UV coordinates that map to a specific number or numbers desired on a particular car from its assigned texture.   Using the {or}  `INCLUDE` statement in a WAG or ENG file, you can specify decal mapping using the `FreightAnim` keyword to locate the related decal `S` file(s).

I'll share a decal creation technique here using Python code for the so inclined in the programming section of this documentation.  The benefits of a code approach is you have a nearly exact idea of how the texture is laid out and can easily adjust the layout to your needs.  The disadvantage is that you have to have the Python programming language installed on your computer along with required graphic packages the code depends on.  If you are not comfortable with Python, then you can use the manual method to lay out your decals, its just a bit more time consuming.

image::images/decal1.png[]

Notice the outline.  That is the shape of the 3D Plane object.  A plane is a single sided shape that we can butt up against the car body.  We rely on the Alpha Mask channel so only the lettering is visible.  The UV coordinates are set to map to the lettering we want to add.  The plnae object is saved as a separate `.s` file and used as `freightAnim` to customize the reporting marks.

image::images/decal2.png[]

=== Layering Basics

(((Graphics, Texture, Using Layers)))

When working on a texture for a model, you are going to want to add bitmap layers that help to achieve the desired final result.  This means being able to adjust the parameters and effects that each layer brings to the final result.  These include making layers with more opacity so the details of lower layers are not obscured, or adding upper layers that contain effects for Grime, Rust, Dirt, Dust, as explained in the now lost "Painting Guide" that once existed on the 3DTrains.com website.  

[NOTE]
Since the 3DTrains website is now off the Internet, some of the things that I learned from that website will be shared here.  Hopefully, 3dTrains folks don't mind that I've tried to share that information here as a sort of archive of what was at the website.

There was an explanation there that you would have you add four NEW layers to your base image and name them Grime, Rust, Dirt and Dust. 


(((Texture, "LAYERING TECHNIQUE")))

==== Grime Layer

* Set the airbrush tool to a width between 150 and 200
* Select a black color, lets say RGB 10,10,10, for example
* Spray all over the layer making sure it looks uneven and spotty
* Now *hide* this layer from view

==== Rust Layer

* With the same airbrush settings, choose a rust color like RGB 136,57,4
* Make sure its sprayed on so you can still see through it.
* Now *hide* this layer from view

==== Dirt Layer

* With the same airbrush settings, choose a yellowish/brown color like RGB 126,113,38
* Make sure its sprayed on so you can still see through it.
* Now *hide* this layer from view

==== Dust Layer

* With the same airbrush settings, choose a light color like RGB 192,192,192
* Make sure its sprayed on so you can still see through it.
* Un-hide all the layers

==== Finalization of effects

* Set the transparency/opacity properties of each of the new layers to somewhere between 10 and 30 percent
* Adjust the percentages of each weathering layer to get the best effects 
* Save the file in the layered format
* Save a copy in the PNG format for use with Blender

=== Applying Fonts and Lettering

(((Graphics, Texture, Using Fonts)))

With the layered format file open, create a new layer just above the BASE layer in the document.  This will make sure that the lettering being added is below the weathering effects. 

[NOTE]
While it might seem like a shameless plug for my website, you will find a number of railroad related fonts at http://www.railsimstuff.com to help with adding lettering and logo details to your textures.  In case you are wondering, the fonts are all free and I make no money from this web site, in fact it only costs me money to keep it running so it is a labor of love that I have provided for nearly 20 years.

As mentioned above, the opacity of the DECAL layer should also be adjusted so it does not hide underlying details.  The effect for decals though needs to resemble having been painted on, so the opacity will mbe much closer to 75% versus a lower value.


==== Layering Tips from Erick

(((Graphics, Texture, Layers, Tips)))

.Erick Cantu on Weathering
[Quote, Erick Cantu]
When I'm walking around, I often find myself taking photographs of dirt, gravel, grass, concrete, and the like. You might think that I take these photos to use as textures. You're sort or right, but mostly wrong. I take these photos primarily to create layer masks used in weathering cars.

(((Texture, "Layering Tips")))

The master textures for all of my cars are always set up like this, from top to bottom:

1. A top mask to keep the overall image tidy
2. Any standalone parts that need to not be affected by the shadow layer
3. A highlight layer which adds a little bit of highlight to selected areas
4. A shadow map which contains the bulk of the detail, including panel lines, ribs, and so on
5. Several weathering layers
6. Car markings
7. The base color layer
8. A wireframe layer for reference (I never look at my cars in shape viewer as I'm painting - first, it wouldn't work, second, the wireframe layer makes it unnecessary)

Here's an example of a simple weathering technique. Freight cars get beaten up pretty severely on the road. They often end up with dents, gouges, and scratches. We can easily create textures for gouges and scratches with photographs of grass. I start with this photo:

image::images/grass.jpg[]


I then turn it to gray-scale and darken it significantly while bumping up the contrast:

image::images/grass-contrast.jpg[]


When you use a gray-scale image as a layer mask, pure white areas will be opaque, while pure black areas will be transparent, with values in between being semi-transparent to varying degrees. It's an opacity map. I can then take a photograph or dirt, or really any image of the right size with some dark color, apply this image as a layer mask, set the properties to "multiply," and end up with dark, scratchy areas all over the car-body. But I can milk that image some more. If you're trying to maximize your output while minimizing your time, it pays to get the most out of all of your resources. I copy the layer, rotate it 180 degrees, invert the colors, and set the properties to "addition." I decrease the opacity to 30%. The end result is this:

image::images/grass-final.jpg[]

Because the textures for the car are not perfectly symmetrical, it's hard to tell that the light, additive layer is the same image as the dark layer, but rotated 180 degrees. Similarly, I can rotate both images 180 degrees, change the opacity values slightly, and add perhaps another layer of spotty dirt, and those same layers easily create a car-body that looks totally different. You could go back to the original image and flip the scratch layers horizontally for a third car-body, or vertically for a fourth.

I am always on the lookout for walls with streaks of dirt from the rain, rusty metal, or anything that looks patchy. You can get so many great layer masks from those things, and most of us are carrying a perfectly-adequate camera in our pockets these days anyway. I used to hate weathering. Now it's quite easy and enjoyable, taking very little of my time.


== Working with Alpha Channels

(((Graphics, Texture, Alpha Channels)))

Historically, {MSTS} has relied heavily on image transparency, the alpha channel in an image, to show intricate details on a model by applying a texture you can see through instead of having to model the actual shapes, thus replacing many object faces with a surface.  It doesn't always work well, but has been used heavily by creators wanting to keep poly counts to a minimum.

In addition, you would use Alpha Channels in an image to create the translucency you see when looking at/through glass such as a window.

Both of these techniques require that you start with an image format that understands the concept of a transparency mask.  In the case of "image cutting", you would rely on a 1 bit Alpha channel that is either see through or opaque, however, in the case of a Window, which is semi opaque, you would rely on a 8 bit Alpha channel with 255 shades of gray between Full Black (transparent) and Full white (opaque).

The tricky part is that every bitmap manipulation tool, GIMP, Paint.NET, PaintShop Pro, etc has their own idea about how to manipulate this Alpha Masking.

*  You can't just use ANY bitmap editor to edit files for transparency manipulation... you need one that actually understands files (like TGA) with an alpha channel embedded.
*  If you use TGA tools, it can separate the MAIN texture from the ALPHA channel and allow you to edit them separately (but they need to come back together at some point, as in - with a TGA FILE.)
*  A .bmp FILE "technically" cannot contain and Alpha Channel... so if you are using a .BMP file... the alpha channel will just be *gone* and it would be something you need to fix/recover.

[NOTE]
There are many formats of BMP bitmap file, including those with alpha channel support. The catch is that those such formats are not commonly encountered on Windows, and most bitmap editors won't edit or deal with them correctly. Therefore, its best to just consider that `.BMP` has no Alpha channel support... so just use `.TGA` or `.PNG`.

=== Creating Alpha Channels with GIMP

(((GIMP, "Alpha Channels")))

This document is a brief tutorial on Alpha Channel usage in GIMP (GNU Image Manipulation Program).  It covers the basics of creating and editing alpha channels (transparency) in GIMP, including how to use the tools, how to select and refine the selection, and how to save your work.

=== Step 1: Start GIMP
Open GIMP (GNU Image Manipulation Program).

=== Step 2: Open your image
Go to `File → Open` and select the image you want to edit.  
TIP: GIMP supports many formats, such as `.png`, `.jpg`, `.bmp`, and `.tif`.

For this example, we'll use a `.png` image that has a sky background that we want to make transparent and a cityscape in the foreground we cant to keep.

image::images/GIMP1.png[]

=== Step 3: Add an alpha channel
To allow transparency, add an alpha channel if one doesn't already exist:  
`Layer → Transparency → Add Alpha Channel`  
(If this option is grayed out, the layer already has an alpha channel.)



=== Step 4: Select the image area
Choose the *Fuzzy Select Tool* (the “Magic Wand” equivalent).  
Click on the part of the image you want transparent.  
Adjust the *Threshold* in the Tool Options to expand or limit the selection.

It might take a few tries to get the selection just right.  Or maybe even invert the selection if you selected the wrong part or selection is easier.
To do this, choose `Select → Invert` or press `Ctrl+I`.

image::images/Screenshot1.png[]


=== Step 5: Refine the selection
Use the *Select → Grow* or *Select → Shrink* commands to fine-tune edges.  
You can also use *Quick Mask* (`Shift+Q`) for precise painting.

image::images/screenshot2.png[]

=== Step 6: Clear or fill the selection
With the selection active:  
* Press **Delete** → removes the selected pixels (they become transparent).  
* Or go to `Edit → Fill with FG/BG Color` (set FG or BG to black/white for alpha control).  

image::images/screenshot3.png[]

NOTE: In GIMP's alpha channel,  
* Black = fully transparent  
* White = fully opaque  
* Gray = semi-transparent  

=== Step 7: Save your work
To preserve alpha transparency, export to a format that supports it:  
* `.png` (recommended for web and most modern uses)  
* `.tga` (if specifically required)  
* `.xcf` (GIMP's native format, for keeping layers and masks editable)

image::images/screenshot4.png[]

Use `File → Export As …` and select your preferred format.  
For PNG, ensure **Save color values from transparent pixels** is enabled.  
For TGA, disable **RLE compression** if compatibility is an issue.

=== Step 8: Optional: Use a layer mask
Instead of directly editing transparency, you can create a layer mask:  
`Layer → Mask → Add Layer Mask` → *Initialize to Selection*.  
This gives you non-destructive control over transparency and can be applied later.

=== Gimp Alpha Wrap Up

Remember to save your project frequently in GIMP's native `.xcf` format, and keep backups of original images.

TIP:  
Using a **layer mask** is usually safer than directly erasing pixels.  
You can always refine the mask with brushes, gradients, or filters — and convert it back into an alpha channel at export.



=== Image Tools

This section lists some of the "extra" tools and functions that are used to create or work with textures.

==== Measuring Tools

(((Measurements)))

Measurements from photos.  Not perfect... but it helps.

https://eleif.net/photomeasure

image::images/_measure00.png[]

==== Dealing with perspective distortion

(((Perspective Distortion)))

For texture pre-processing, particularly for photo-based texturing, I use the following tool: https://renderhjs.net/shoebox/ to perform a fix for perspective warping when the photo is not taken directly square on the object.  It requires ADOBE AIR to run, which is available from Harman International since Adobe stopped supporting it. https://airsdk.harman.com/download

image::images/shoebox1.jpg[]

The "texture ripping" option in the program allows you to clip pieces from a master image and you are able to adjust the alignment while you are doing it.  This is a great way to get a good start on your photo based textures.  

image::images/radio1.png[]

The image to be manipulated should be in your copy/paste buffer before starting the texture tipping process.  You then click 4 adjustment points on the image and the program will automatically adjust the image to fit the 4 points. 

image::images/ripper.jpg[]

You can then save the image to your drive as a texture file you can import into your bitmap editor.

image::images/radio.png[]


=== ACE2BMP

(((ACE2BMP, Tools)))    

ACE2BMP is a command line tool - to use in scripts - to covert ACE texture files to BMP texture files. It was created by David Webb and tested by me. Usage: ACE2BMP.exe [Source Ace] [Destination BMP]. (issued under GNU General Public License) By Scott Brunner

It is available at ElvasTower Downloads section.  For the technical types, the original author's source code is available at https://github.com/djw-zr/ace2bmp

=== ACEIT

(((AceIt, Tools)))

AceIt is a program designed to produce Kuju ACE format texture files from many common image formats. It is intended to be used as a replacement for the the {MSTS} supplied tools `MAKEACE` and `MAKEACEwin` tools.

Aceit contains the newest and best methods for working with .ace files. 

* You start with a .bmp file which you can generate using MS Paint or other drawing program. (Unless your texture has an alpha channel (transparency) then you would generate a .tga file). 
* Then run Aceit. 
* Enter as the input the .bmp file you created then enter where the output will go (usually your routes texture folder)
* Then finally, save it.

[NOTE]
Aceit itself is very old and it may have difficulty being installed ot get running on modern Windows systems.  You may need to run it in compatibility mode for Windows XP SP3 or consider using ACE2BMP utility.



=== TGATOOL2 and MAKEACE tools

(((TGATool2, MAKEACE, Tools)))

If you want to continue to work with `.ace` file format defined by {MSTS}, then these 2 tools, TGATool2 and MAKEACE were pretty much the starting point for texture manipulation. These tools are quite old.

TGATool2:: a standalone program for working with the `.bmp`. Targa `.TGA` and `.Ace` files used by Trainsim.  It works in conjuction with the MAKEACE utility. There is an updated version in ACEIT.

MAKEACE:: The MAKEACE utility converts industry-standard image file formats into the Kuju image file format known as ACE (extension .ACE) which can be used with
Microsoft Train Simulator.  MAKEACE supports Windows Bitmap files (extension .BMP) which contain 24-bit RGB encoded images and Truevision Targa files
(extension .TGA) which contain 24-bit RGB encoded or 32-bit RGBA (Red, Green, Blue + alpha "translucency" channel) encoded images.

[NOTE]
The default MAKEACE utility that was supplied with {MSTS} has limitations and it is highly recommended that you replace it with the ACEIT utility. At the very least, get the MSTS TOOLS 1.4 update.   

[NOTE] 
I no longer recommend using TGAtools2 from MGGrapphics unless you are just trying to recover images from existing ACE files.

When you need to modify a texture that has been saved in the .ace file format, TGATools2A is typically the software of choice for opening the .ACE file. You can obtain TGATools2A through an Ace-It utility installation. Once you have the .ace file open in TGATools2A, it's advisable to promptly save it as a .tga file.

While the .ace format is primarily used within MSTS (Microsoft Train Simulator), the Targa format (.tga) is more versatile and compatible with a wider range of software applications. TGATools2A offers the capability to independently edit the color and alpha components of the texture. Alternatively, you can also open the .tga file in software like Photoshop, PaintShop Pro, etc and make direct edits.

[TIP]
It's important to understand that simply "applying alpha" to any texture and expecting it to function seamlessly on any model is not always feasible. While it's possible to "transparently remove" portions of a model by adding an alpha channel to the texture, it may also be necessary to modify the shape file to properly utilize the alpha component of the texture. However, if your goal is to merely correct the existing alpha, and the shape is already set up for it, these considerations may not be applicable in this context.


=== DXTBMP

(((DXTBMP, Tools)))

This is a tool that is also available from MWGFX website, as is TGATOOLS2.  Images can be passed to any paint program for editing in 24 bit and then re-imported and saved in any of the 16/24/32 bit formats.  Transparency (Alpha) channel of textures can be viewed and edited separately from the main image.  It supports `.DDS` files.


Example Session: 

* Open the "Original " ace with the alpha included. 
* Under the "Alpha " setting go to extract the alpha. 
* Click kbd:[yes] , kbd:[ok] 
* Name the "alpha" you extracted and place in the `ace` you created.
* Open your image with DXTBMP and import the "Alpha" into your image. 
* At the bottom of the "Alpha" setting,  Click kbd:[Apply Alpha to Image] and you should be done. 

[NOTE]
This applies too both `ace` and `dds` files

[TIP]
It's really just easier to use a tool like Paint.net for creating the `.DDS` file.

<<<

=== ACE2DDS 
(((ACE2DDS, Tools)))

ACE → PNG → DDS Conversion Tools - These utilities simplify working with Microsoft Train Simulator (MSTS) and Open Rails legacy ACE texture formats. https://github.com/pwillard/Ace2DDS/releases

The download contains two tools:

* `ace2png.exe` - This tool converts the ACE texture(s) file to a PNG file.
* `tex2dds.exe` - This tool converts the PNG file(s) to a DDS texture file.

Both tools are command-line tools, so you can run them from a command prompt or terminal window. _Items in brackets are optional arguments._

To use the `ace2png.exe` tool, run it with the following command-line arguments:

```
usage: ace2png.exe [-h] [-o OUT] source
```

Replace `input.ace` with the path to the ACE texture file you want to convert, and replace `output.png` with the path where you want to save the PNG file.

To use the `tex2dds.exe` tool, run it with the following command-line arguments:

```
usage: tex2dds.exe [-h] [-o OUT] [--texconv TEXCONV] [--srgb] source
```

Replace `input.png` with the path to the PNG file you want to convert, and replace `output.dds` with the path where you want to save the DDS file.

[TIP]
You can also process entire folders of ACE texture files at once with `ace2png` if you supply a folder name as the "source" and DDS file conversions with `tex2dds` if you supply a folder name as the "source".














=== Alpha materials in Blender

(((Blender, Materials with Alpha Layer)))

If you want to just keep your hair in your head, versus pulling it out... here is a recommendation.

* Use Paint.Net or GIMP or Affinity Studio
* Use the NATIVE format of your selected Bitmap Editor as your master file. (They will support "layers")
* Export your bitmaps in TGA or PNG format for use as Blender Texture files.

[NOTE]
Affinity products do not support exporting to DDS, but you can use Paint.NET or GIMP to export the file used by Blender to the DDS format usable with {or}. You could also used command line tools to convert PNG files to DDS.

When you finally export your model(s) to the `S` file format using the MSTS/{or} Exporter script, export the DDS format from Paint.net or GIMP as a follow-up step.

==== The Shader Editor

If you were look at a typical setup in the shader editor for a texture that contains an alpha channel, you would see this.

image::images/alpha1.PNG[]

It looks pretty straight-forward, but heed this warning, this is just related to what you `SEE`, and not what you export.  

==== The MSTS Materials Settings

For exporting to {OR} and {MSTS}, you need to also have the MSTS Materials settings adjusted.  See below:

image::images/alpha2.PNG[]

For most scenarios where an alpha channel is used, this `Alpha Blended` setting is good enough and it works OK in my experience, so try it first. It is the gray scale Alpha Channel used for Glass, while `Transparancy ON/OFF` is the one bit mask where only BLACK RGB (0.0.0) is transparent in a mask.



== How to Make Night Textures

(((Texture, Seasonal)))
[NOTE]
Much of this is content is a summary of KUJU supplied documentation along with some other notes from other sources.

Night textures on shapes are created by editing the original texture, darkening it and perhaps adding a couple of touches for effect.

The night textures take effect at a predetermined time within the game environment, so as to replicate a real world environment. The `extshape.dat` file must be updated with the correct parameters so that the shape is declared as having night textures (see the “How to write a .ref file” document for further clarification). ((( Reference File)))

Once created, the night and day textures must have the same filename so that the code can pick up the correct texture. This means that the daytime / normal texture must be entered into the normal route textures directory and the night version into the route night textures directory.

Below are two textures taken from the Orient Express level. These were
manipulated in a two dimensional drawing package:

image::images/image1.jpeg[]
image::images/image2.jpeg[]
image::images/image3.jpeg[]
image::images/image4.jpeg[]

This means that the texture on the left will be replaced with the
texture on the right once the correct night timing has been switched on.

== How to Make Night Textures with Back Lighting

Example: 

Create the image for the building you want to texture, making sure that anything that requires a backlight is a separate objects and textures.  Items such as windows should be separate objects, often created by just using a PLANE object.

The basic building shape should not have modeled windows.   The window parts of the texture will be modified to use an alpha channel. The image can then be saved as a working PNG file if your editor allows it, or you could use a PSD format as you just need a format that retains layers.


If you are also working on the 3D MODEL while texturing, you would not model the windows doors or outdoor lights. You would work on these items as the last steps in the process. In essence, you would completely texture the model before proceeding to work on the lighting effects.



== How to Make Snow Textures

(((Texture, Snow)))

Snow textures must also be created, so that your buildings and other
objects will look correct when there is snow lying on the ground. These,
too, are created using the original, daytime textures. The `extshape.dat`
file must be updated in relation to this (see the “How to write a .ref
file” document for further clarification) and must be placed in the
route's snow textures directory accordingly. The snow texture will only
be used when the snow environment settings have been switched on through
the Drive a Train User Interface.

Below are the snow versions of the textures above.

image::images/image1.jpeg[]

image::images/image5.jpeg[]

image::images/image3.jpeg[]

image::images/image6.jpeg[]

=== Highlights and Shadows

(((Texture, "Shadows")))

A layer, or layers, used for "hard coded" shadows and possibly highlights, which could otherwise be known as the {AO} layer, should reside near the DECAL layer and the BASE layer for a decent effect, though you could migrate the highlights layer higher in the stack.  How to create an {AO} layer using the Blender render engine is covered in another section of this document, but if you do create this layer using Blender, this is where it would be inserted.  The color of this layer will essentially be only black and white.  You can always choose to create and edit this layer manually as well. 

[TIP]
The blend mode for the [ao] layer could also be "multiply" instead of "normal"

== Generated Shadows - Ambient Occlusion

(((Texture, ambient occlusion)))

{AO} is the generation of hard-coded or `baked` shadows instead of relying in dynamic lighting to generate shadows for an in-game asset.  It provides extra depth to an asset that would not be achieved otherwise.

Marek on Elvas Tower shared how he achieves {AO} on his models and it is shared here.  

[TIP]
There are many ways to achieve {AO} in Blender, so you will probably need to experiment with methods to see which one works best for your model or your sanity.

[NOTE]
Your model needs to be UV UNWRAPPED prior to baking out an {AO} image as described here.

image::images/ao0.jpg[]


An orthographic camera can be used to render the {AO} with all projection planes. Clipping planes can then be used on the camera to make certain parts invisible to the render camera, which helps exclude details that are not desired. The renders can then be imported into GIMP (or any other editor that supports layers) and used as the base for the final texture layout. The model can then be unwrapped to that. Livery colors can then be added in layers above the {AO} layers and layer blend modes can be used to create the desired image. This method is more time-consuming than other methods, but it produces results that are far better than what can be achieved by hand in 2D alone.

image::images/ao1.jpg[]

The image above shows a model with a single material applied to it called `au_bhpb_sd70ace_4096`. In the shader editor, two inputs can be chosen for the Base Color of the `Principled BSDF:` either an image file applied to the model at the top or an {AO} shader via a Color Ramp node below it. When exporting to `.S` or wanting to view the texture in Blender, the `texture node` needs to be plugged in, and when rendering the {AO}, the {AO} Shader needs to be plugged in. By setting the 3D viewer to `Rendered`, one can get an idea of what the output will look like and can adjust the shadow effect via the sliders in the ColorRamp.

image::images/ao2.jpg[]

In the Render properties tab, switch your Render Engine to Cycles and your Device to GPU Compute for faster rendering. With a Render sample setting of 128, rendering can take a while on a PC. To get a faster render time when testing, try using a lower number initially. Don't forget to turn on `Denoise` to give you a cleanly rendered image.

image::images/ao3.jpg[]

In the Output properties tab,  the  `Format Resolution X = 4096 px` is used because there is a 4K texture being used on the model. You can adjust the Resolution Y value later when you know how much vertical space the render will take (see below).

image::images/ao4.jpg[]

A camera should be added to the scene and moved to the side of the locomotive. The Rotation values in the Properties tab should be used to ensure that it is perpendicular to the locomotive. On the Object Data Properties tab, the Type of Camera should be changed to Orthographic. A separate 3D viewport should be opened and the Camera should be selected and kbd:[CTRL + Num 0] should be pressed to get a side view of the locomotive from the camera's point of view. If it is not already in Rendered view, pressing kbd:[Z] should allow for Rendered view to be selected; the {AO} shader should be visible in the camera view. 

The Orthographic Scale should be adjusted for the camera so that the entire length of the locomotive body fills the camera view (for this locomotive, the scale is 22.300). The camera should be moved in the `Y` and `Z` axes to ensure that it is in frame. Then, the `Format Resolution Y = value` should be adjusted so that no empty space is rendered above and below the locomotive. When the entire locomotive is framed in the camera view, kbd:[F12] should be pressed and Blender will render the {AO} into a new window.

If denoise is enabled, the rendering may appear to hang, but it will complete after a while. Making multiple copies of the camera and moving them to the sides, ends, top and bottom is recommended in order to render the {AO} from the different projections. Keeping the `Orthographic Scale` the same on all the cameras will result in the render being at the same textural density. Additionally, unlike a perspective camera, the distance of the camera from the object does not change the size of the resultant render.

Once you have finished rendering the image, you can save it to your computer and import it into your 2D graphics program to use as a base for your texture. To make sure the texture has the same textural density, you should make multiple copies of the camera and move them to the sides, ends, top and bottom. Again, unlike with a perspective camera, the distance of the camera from the object will not affect the size of the render. However, the hand rails may obstruct the details on the body behind. To fix this, you have multiple options.

image::images/ao5.jpg[]

In the image above the `X` location of the camera is 10m to the side of the locomotive.  The `Clip Start` distance has been changed from its default value of 0.1m to 8.7m. When rendered, the view no longer includes the handrails but displays the side of the body as the camera is drawing what it can see from 8.7m to 1000m, beyond the hand rail closest to the camera. This clipping results in the cab side, fuel tank and air tanks being cut off. The same outcome can be achieved by keeping the `Clip Start` and `End` at their default settings and moving the camera in the `X` direction, allowing for 'slices' of the scene similar to an MRI machine.

image::images/ao6.jpg[]

It is possible to make parts invisible to the render camera. In the image, the `Camera` checkbox in the Object Properties tab for the hand rails and air tank objects has been unchecked. This results in the entire side of the locomotive body being visible in the render view, but the handrails and air tanks not being rendered. These methods can be used to exclude objects in the foreground that are not required for the desired image.

The {AO} can be rendered for all the different views and then mashed together in a 2D graphics program to export as the `au_bhpb_sd70ace_4096` texture to use for unwrapping and in Open Rails.

This technique for Baking {AO} is a good way to get the added shadow details on a texture but the method described here is not the only way to accomplish {AO} shadows.  It might not be the most effcient way either, but it seems to work.

[NOTE]
It is important to be aware that any lights in the scene, including environment lighting, will impact the rendered {AO}. Lights are not used when baking an {AO}, so if the rendered {AO} image is too dark, the environment brightness can be increased or area lights can be added, typically the length of the locomotive, placed on either side to minimize shadow casting. If the lighting is changed later on, this will impact subsequent renders and will not match earlier renders. It is essential to be aware of this.

 



image::images/ao7.jpg[]

=== Ambient Occlusion, workflow

(((Texture, "Ambient Occlusion Baking")))

To Recap... Blender {AO} (AO) is a rendering technique that simulates the subtle shadows that occur where surfaces meet other surfaces or when they are blocked from direct light. AO can be used to add realism and depth to your renders, and it can be especially effective for close-up shots or scenes with complex geometry.

There are a few ways to add AO to your renders in Blender, these include:

1. Render settings: Go to Render Properties > Render Settings > World and enable the {AO} checkbox. You can then adjust the Distance and Strength settings to control the intensity of the AO effect.
2. Shader node: Add an {AO} node to your material shader and connect it to the Surface output. You can then adjust the Distance and Strength settings directly on the node.

Tips for using AO in Blender:

* AO can be computationally expensive, so it is important to use it sparingly. If you are rendering a scene with a lot of geometry, consider using a lower sample count or baking the AO to a texture.
* AO can be used to add subtle details to your renders, but it is important not to overdo it. Too much AO can make your renders look dark and muddy.
* AO can be used to create a variety of effects, such as weathering, dirt, and grime. Experiment with different settings to achieve the desired look.

Here are some examples of how AO can be used to improve the realism and depth of your renders:

* Close-up shots: AO can be used to add subtle shadows and details to close-up shots of characters, objects, and environments. This can help to make your renders look more realistic and believable.
* Scenes with complex geometry: AO can be used to add depth and definition to scenes with complex geometry, such as city scapes, forests, and interiors. This can help to make your renders look less flat and more immersive.
* Weathering and dirt effects: AO can be used to create a variety of weathering and dirt effects, such as dust on a car or moss on a tree trunk. This can help to make your renders look more realistic and worn-in.

Overall, AO is a powerful rendering technique that can be used to add realism and depth to your renders. By understanding the basics of AO and experimenting with different settings, you can achieve a variety of effects to enhance your renders.

=== Ambient Occlusion Baking with GIMP

(((Texture, "Ambient Occlusion Baking, GIMP")))

[TIP]
Tips from Marek

Here are the settings I use in the shading menu when I perform an AO bake.

image::images/AO_Bake_Blender.jpg[]

Firstly, ignore the Metallic and Roughness texture nodes connected to the Principled BSDF shader. These are used for glTF exports and will not impact on AO baking or .S export.

This model uses a single 4K texture for the external model called generic_sd40-2_4096.png. Each object on the model has had its faces UV Mapped to a unique location where I want it on the texture file.

When ready to bake, I create a new 4K image texture node called AO_BAKE_4096.png. You can see this node below the principled BSDF but it is not connected to anything. I leave it below and to the right of the Principled BSDF so that it is easy to find and to remind me not to connect it to anything.

In the Render Properties tab I have set the samples to 2048 which is high but gives a fine high resolution AO. Denosie is ticked as it improves the quality of the bake. I use the OptiX Denoiser as this is faster on my graphics card. Bake type is set to Ambient Occlusion. Device is set to GPU compute because Nvidia 2070 is considerably faster at baking than CPU. Version 4 of Blender can use the Vulkan engine which is supposed to be faster than OpenGL which is limited to being single threaded as I understand it. Test both to see which is faster for you using Edit > Preferences > System > Display Graphics > Backend > Vulkan or OpenGL

I always bake at least 2 objects at the same time. If I bake a single object I get a black background for some reason. If I have 2 or more objects selected when baking, I get a transparent background which is what I want when importing into my 2D graphics program.

Also before baking, I unplug the Alpha noodle between the Base Colour and Principled BSDF. If the alpha noodle is connected, and the UV Map of the object being baked is over an untextured/alpha area of the base colour, the resultant bake will be all black. Took me ages to work this one out.

When the objects I want to bake are UV Mapped over a unique area of the texture file, I again ensure that the alpha noodle is not connected. I confirm I have 2 or more objects selected. I then left click to highlight the AO_BAKE_4096.png texture in the Shader Editor. This is important as Blender will now render the bake to the selected texture. In the UV editor on the left hand side I have the target AO_BAKE_4096.png texture selected so I can see the progress of the baking process.

I then click on the 'Bake' button in the 'Render Properties' tab. The progress bar along the bottom of the screen shows how slowly it is going. The denoising does not show in the progress bar and makes Blender look like it has frozen. Baking objects with a small number of faces does not take long. For large parts with many triangles 10-15 minutes at 2048 samples is the norm with my models on my computer.

Once the bake has completed, I use the Image > Save As drop down menu in the UV Editor and I save the file as AO_BAKE_4096.png.

In the Blender screen shot you can see the AO for the fuel tank on the bottom left of the texture with the rest of the area being transparent/alpha.

I then go into GIMP and then import the AO_BAKE_4096.png file as a layer on top of my already present AO layer which is a combination of all the other objects that have baked the AO for over time.

image::images/AO_Bake_GIMP1.jpg[]

I then merge that imported AO layer into the existing AO layer so I have a single AO layer. Below this AO layer I have the diffuse colours. I then apply the 'Multiply' mode to the AO layer that blends it with the underlying coloured layers.

image::images/AO_Bake_GIMP2.jpg[]

I then export this from GIMP as the texture file that is applied to the model in Blender, in this model it is generic_SD40-2_4096.png and export it as generic_SD40-2_4096.dds for use directly in OpenRails.

The next object/s that need to have their AO baked, are unwrapped to another unique location on the texture file, selected and baked to the AO_BAKE_4096.png file as described above. This same file is used to transfer the AO bake from Blender to be combined with the AO layer in GIMP.

If you are using texture files with different resolutions then make the texture file you are going to bake the AO to the same size.

If you get unexpected black areas in your bake then that can be caused by different things. Having the alpha noodle connected when baking has already been mentioned above. Flipped normals are another common cause. Other geometry overlapping the baked surface is another common cause. These can be hard to find, especially if you have hidden some objects, they still mask the baking process.

=== More About Baking Ambient Occlusion

(((Texture, "Baking Ambient Occlusion, additional")))


{AO} Baking is potentially a confusing task in Blender. Here is an alternate method for baking ambient occlusion if you want a bit more control over the process.

When Baking occlusion, Here are some general tips (From Wayne Campbell):

1. Gather parts that will receive{AO} into a collection to make them easy to select.
2. Ensure the UV Maps for those parts do not wrap off the edge of the texture sheet.
3. Coplanar surfaces are a problem, including two sided, they bake black.
4. Set 'Render Engine' to Cycles.
5. Set Render Max Samples low eg 8, for testing, high for better quality , eg 128, 256 etc
6. If your model has secondary LOD's ensure they don't cast a shadow on your primary model, use 'Disable In Render' in the outliner

[WARNING]
When baking {AO}, you should select at least 2 objects at the same time. If you select only one object, the bake will be black. If you select more than 2 objects, the bake will be properly transparent.


=== {AO} Steps

To bake {AO} in Blender, you can use the Bake tool in the Render tab of the Properties panel. Here's a step-by-step guide:

* Select the object or objects that you want to bake the{AO} for.
* In the Properties panel, go to the Render tab and then click on the Bake tab.
* In the Bake tab, set the Bake Mode to clusion.
* Set the Samples value to the number of samples you want to use for the{AO} bake. The higher the value, the more accurate the{AO} will be, but the longer the bake will take.
* Set the Margin value to add a margin around the baked texture to prevent texture bleeding.
* Set the Space to either "Object" or "World" depending on whether you want the{AO} to be baked in object space or world space.
* Check the "Clear" box to clear the image before baking.
* Check the "Normalized" box to normalize the{AO} values, which can help with artifacts and banding.
* Click the "Bake" button to start the{AO} bake.

[Note] 
The{AO} bake can take some time, depending on the complexity of the objects and the number of samples you are using. Once the bake is complete, the{AO} map will be saved as an image in the UV/Image Editor. You can then use this image as a texture to apply the{AO} effect to your object.

